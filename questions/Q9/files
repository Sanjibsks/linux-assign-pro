1. zombie_prevent.c (Main C program)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <string.h>
#include <errno.h>

#define MAX_CHILDREN 100

// Function to print timestamp
void print_time() {
    time_t now;
    time(&now);
    printf("[%s] ", ctime(&now));
    // Remove newline from ctime output
    printf("\b");
}

// Function to validate input
int validate_input(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Error: Please provide the number of child processes to create\n");
        fprintf(stderr, "Usage: %s <num_children>\n", argv[0]);
        return -1;
    }
    
    char *endptr;
    long num_children = strtol(argv[1], &endptr, 10);
    
    if (*endptr != '\0') {
        fprintf(stderr, "Error: Invalid argument. Please provide a positive integer.\n");
        return -1;
    }
    
    if (num_children <= 0) {
        fprintf(stderr, "Error: Number of child processes must be positive (greater than 0)\n");
        return -1;
    }
    
    if (num_children > MAX_CHILDREN) {
        fprintf(stderr, "Warning: Limiting to %d child processes\n", MAX_CHILDREN);
        return MAX_CHILDREN;
    }
    
    return (int)num_children;
}

int main(int argc, char *argv[]) {
    int num_children = validate_input(argc, argv);
    if (num_children <= 0) {
        return EXIT_FAILURE;
    }
    
    pid_t pid;
    int i;
    struct timespec start_time, end_time;
    
    // Get start time
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    printf("\n========================================\n");
    printf("   ZOMBIE PROCESS PREVENTION DEMO\n");
    printf("========================================\n");
    printf("[PARENT] PID: %d - Starting zombie prevention demo\n", getpid());
    printf("[PARENT] Creating %d child processes...\n\n", num_children);
    
    // Array to store child PIDs
    pid_t child_pids[MAX_CHILDREN];
    
    // Create child processes
    for (i = 0; i < num_children; i++) {
        pid = fork();
        
        if (pid < 0) {
            // Fork failed
            perror("fork");
            fprintf(stderr, "[PARENT] Fork failed for child %d\n", i+1);
            // Clean up already created children before exiting
            for (int j = 0; j < i; j++) {
                waitpid(child_pids[j], NULL, 0);
            }
            return EXIT_FAILURE;
            
        } else if (pid == 0) {
            // Child process
            srand(getpid() + time(NULL));
            int sleep_time = (rand() % 5) + 1; // Sleep 1-5 seconds
            
            printf("[CHILD %d] PID: %d - Started, will run for %d seconds\n", 
                   i+1, getpid(), sleep_time);
            fflush(stdout);
            
            // Simulate work
            sleep(sleep_time);
            
            printf("[CHILD %d] PID: %d - Exiting after %d seconds\n", 
                   i+1, getpid(), sleep_time);
            fflush(stdout);
            
            exit(EXIT_SUCCESS);
            
        } else {
            // Parent process - store child PID
            child_pids[i] = pid;
        }
    }
    
    // Parent process: Wait for all children to prevent zombies
    printf("\n[PARENT] Waiting for child processes to terminate...\n");
    printf("========================================\n");
    
    int status;
    pid_t reaped_pid;
    int reaped_count = 0;
    
    // Method 1: Using wait() - blocks until any child exits
    // Method 2: Using waitpid() with each specific child PID
    // We'll demonstrate waitpid() for more control
    
    for (i = 0; i < num_children; i++) {
        // Wait for specific child process
        reaped_pid = waitpid(child_pids[i], &status, 0);
        
        if (reaped_pid == -1) {
            perror("waitpid");
            fprintf(stderr, "[PARENT] Error waiting for child PID: %d\n", child_pids[i]);
        } else {
            reaped_count++;
            
            if (WIFEXITED(status)) {
                printf("[PARENT] Reaped child PID: %d with exit status: %d\n", 
                       reaped_pid, WEXITSTATUS(status));
            } else if (WIFSIGNALED(status)) {
                printf("[PARENT] Child PID: %d terminated by signal: %d\n", 
                       reaped_pid, WTERMSIG(status));
            } else {
                printf("[PARENT] Child PID: %d terminated abnormally\n", reaped_pid);
            }
        }
    }
    
    // Get end time and calculate duration
    clock_gettime(CLOCK_MONOTONIC, &end_time);
    double duration = (end_time.tv_sec - start_time.tv_sec) + 
                     (end_time.tv_nsec - start_time.tv_nsec) / 1e9;
    
    printf("\n========================================\n");
    printf("[PARENT] All child processes have been cleaned up\n");
    printf("[PARENT] Reaped %d of %d child processes\n", reaped_count, num_children);
    
    // Check if any zombie processes remain
    printf("[PARENT] Checking for zombie processes...\n");
    
    // Try to wait for any remaining children (non-blocking)
    while ((reaped_pid = waitpid(-1, &status, WNOHANG)) > 0) {
        printf("[PARENT] Found and reaped stray child PID: %d\n", reaped_pid);
        reaped_count++;
    }
    
    if (reaped_count == num_children) {
        printf("[PARENT] No zombie processes remain âœ“\n");
    } else {
        printf("[PARENT] Warning: %d children may not have been cleaned up\n", 
               num_children - reaped_count);
    }
    
    printf("[PARENT] Total execution time: %.2f seconds\n", duration);
    printf("========================================\n\n");
    
    return EXIT_SUCCESS;
}

2. Makefile
makefile

CC = gcc
CFLAGS = -Wall -Wextra -std=c11 -D_POSIX_C_SOURCE=200809L
TARGET = zombie_prevent
SOURCES = zombie_prevent.c

all: $(TARGET)

$(TARGET): $(SOURCES)
	$(CC) $(CFLAGS) -o $(TARGET) $(SOURCES)

debug: $(SOURCES)
	$(CC) $(CFLAGS) -g -o $(TARGET)_debug $(SOURCES)

clean:
	rm -f $(TARGET) $(TARGET)_debug zombie_create waitpid_demo signal_zombie

run: $(TARGET)
	./$(TARGET) 5

test: $(TARGET)
	@echo "=== Testing with 3 children ==="
	./$(TARGET) 3
	@echo ""
	@echo "=== Testing with 8 children ==="
	./$(TARGET) 8

.PHONY: all clean run test debug

3. zombie_create.c (Program that creates zombies)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <num_children>\n", argv[0]);
        return 1;
    }
    
    int num_children = atoi(argv[1]);
    
    printf("\n[PARENT] Creating %d zombie children...\n", num_children);
    
    for (int i = 0; i < num_children; i++) {
        pid_t pid = fork();
        
        if (pid == 0) {
            // Child process
            printf("[CHILD %d] PID: %d - Started (will become zombie)\n", 
                   i+1, getpid());
            fflush(stdout);
            
            // Exit immediately without parent waiting
            exit(0);
        } else if (pid > 0) {
            // Parent continues creating children
            usleep(100000); // Small delay
        } else {
            perror("fork");
            return 1;
        }
    }
    
    printf("[PARENT] Not waiting for children. They will become zombies...\n");
    printf("[PARENT] Sleeping for 60 seconds. Check with: ps aux | grep defunct\n");
    
    // Parent sleeps without calling wait()
    sleep(60);
    
    return 0;
}

4. waitpid_demo.c (Demonstrating waitpid() options)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <num_children>\n", argv[0]);
        return 1;
    }
    
    int num_children = atoi(argv[1]);
    pid_t pids[num_children];
    
    printf("[PARENT] Using waitpid() with WNOHANG option\n");
    printf("[PARENT] Creating %d child processes...\n", num_children);
    
    // Create children
    for (int i = 0; i < num_children; i++) {
        pid_t pid = fork();
        
        if (pid == 0) {
            // Child
            srand(getpid());
            int sleep_time = (rand() % 4) + 1;
            printf("[CHILD %d] PID: %d - Running for %d seconds\n", 
                   i+1, getpid(), sleep_time);
            sleep(sleep_time);
            printf("[CHILD %d] PID: %d - Exiting\n", i+1, getpid());
            exit(0);
        } else {
            pids[i] = pid;
        }
    }
    
    printf("\n[PARENT] Polling for completed children (non-blocking)...\n");
    
    int reaped = 0;
    while (reaped < num_children) {
        int status;
        pid_t pid = waitpid(-1, &status, WNOHANG);
        
        if (pid > 0) {
            printf("[PARENT] Poll: Reaped child PID: %d\n", pid);
            reaped++;
        } else if (pid == 0) {
            printf("[PARENT] Poll: No children have exited yet\n");
            sleep(1); // Wait before polling again
        } else {
            perror("waitpid");
            break;
        }
    }
    
    printf("\n[PARENT] All children reaped using waitpid() with WNOHANG\n");
    return 0;
}

5. signal_zombie.c (Using SIGCHLD handler)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <time.h>

volatile sig_atomic_t child_count = 0;
volatile sig_atomic_t total_children = 0;

// Signal handler for SIGCHLD
void sigchld_handler(int sig) {
    int status;
    pid_t pid;
    
    // Reap all available children
    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        printf("[SIGCHLD HANDLER] Received signal for child termination\n");
        printf("[SIGCHLD HANDLER] Reaped child PID: %d\n", pid);
        child_count++;
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <num_children>\n", argv[0]);
        return 1;
    }
    
    total_children = atoi(argv[1]);
    
    // Set up signal handler
    struct sigaction sa;
    sa.sa_handler = sigchld_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
    
    if (sigaction(SIGCHLD, &sa, NULL) == -1) {
        perror("sigaction");
        return 1;
    }
    
    printf("[PARENT] Using SIGCHLD handler for zombie prevention\n");
    printf("[PARENT] Creating %d child processes...\n", total_children);
    
    // Create children
    for (int i = 0; i < total_children; i++) {
        pid_t pid = fork();
        
        if (pid == 0) {
            // Child
            srand(getpid());
            int sleep_time = (rand() % 3) + 1;
            printf("[CHILD %d] PID: %d - Running for %d seconds\n", 
                   i+1, getpid(), sleep_time);
            sleep(sleep_time);
            exit(0);
        } else if (pid < 0) {
            perror("fork");
            return 1;
        }
    }
    
    // Parent waits for all children to finish
    while (child_count < total_children) {
        pause(); // Wait for signals
    }
    
    printf("\n[PARENT] All children have terminated\n");
    return 0;
}

6. run_tests.sh (Test script)
bash

#!/bin/bash

echo "=== Zombie Process Prevention Test Suite ==="
echo "Compiling programs..."
make clean
make

echo ""
echo "=== Test 1: Basic functionality (5 children) ==="
./zombie_prevent 5

echo ""
echo "=== Test 2: Different number of children ==="
./zombie_prevent 2
./zombie_prevent 7

echo ""
echo "=== Test 3: Error handling ==="
./zombie_prevent
./zombie_prevent 0
./zombie_prevent abc

echo ""
echo "=== Test 4: Performance test (20 children) ==="
time ./zombie_prevent 20

echo ""
echo "=== Test 5: Comparing with zombie creator ==="
echo "Running zombie creator in background..."
./zombie_create 3 &
ZOMBIE_PID=$!
sleep 2
echo "Checking for zombie processes:"
ps aux | grep -E "(zombie_create|defunct)" | grep -v grep
kill $ZOMBIE_PID

echo ""
echo "=== Test 6: waitpid() demo ==="
gcc -o waitpid_demo waitpid_demo.c
./waitpid_demo 4

echo ""
echo "=== Test 7: Signal handler demo ==="
gcc -o signal_zombie signal_zombie.c
./signal_zombie 3

echo ""
echo "=== All tests completed ==="
