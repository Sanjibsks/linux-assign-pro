1. signal_demo.c (Main signal handling program)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <string.h>
#include <errno.h>

// Global variables for signal handling
volatile sig_atomic_t sigterm_received = 0;
volatile sig_atomic_t sigint_received = 0;
volatile sig_atomic_t shutdown_initiated = 0;

// Function to print formatted header
void print_header(const char* title) {
    printf("\n╔════════════════════════════════════════╗\n");
    printf("║%*s%s%*s║\n", (int)(20 - strlen(title)/2), "", title, 
           (int)(20 - strlen(title)/2 - (strlen(title)%2 ? 1 : 0)), "");
    printf("╠════════════════════════════════════════╣\n");
}

// Function to print formatted footer
void print_footer() {
    printf("╚════════════════════════════════════════╝\n");
}

// Signal handler for SIGTERM
void sigterm_handler(int sig) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    double current_time = ts.tv_sec + ts.tv_nsec / 1e9;
    
    print_header("SIGNAL HANDLER ACTIVATED");
    printf("║ Signal: SIGTERM (%d)%*s║\n", sig, 27, "");
    printf("║ Time received: %.2f seconds%*s║\n", current_time, 18, "");
    printf("║ Handler: Graceful shutdown initiated%*s║\n", 5, "");
    print_footer();
    
    sigterm_received = 1;
    shutdown_initiated = 1;
}

// Signal handler for SIGINT
void sigint_handler(int sig) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    double current_time = ts.tv_sec + ts.tv_nsec / 1e9;
    
    // Only print if we haven't already started shutdown
    if (!shutdown_initiated) {
        print_header("SIGNAL HANDLER ACTIVATED");
        printf("║ Signal: SIGINT (%d)%*s║\n", sig, 28, "");
        printf("║ Time received: %.2f seconds%*s║\n", current_time, 18, "");
        printf("║ Handler: Interrupt received%*s║\n", 12, "");
        print_footer();
        
        shutdown_initiated = 1;
    }
    
    sigint_received = 1;
}

// Function to set up signal handlers
void setup_signal_handlers() {
    struct sigaction sa_term, sa_int;
    
    // Setup SIGTERM handler
    memset(&sa_term, 0, sizeof(sa_term));
    sa_term.sa_handler = sigterm_handler;
    sa_term.sa_flags = SA_RESTART;
    sigemptyset(&sa_term.sa_mask);
    
    if (sigaction(SIGTERM, &sa_term, NULL) == -1) {
        perror("sigaction SIGTERM");
        exit(EXIT_FAILURE);
    }
    printf("[PARENT] SIGTERM handler installed\n");
    
    // Setup SIGINT handler
    memset(&sa_int, 0, sizeof(sa_int));
    sa_int.sa_handler = sigint_handler;
    sa_int.sa_flags = SA_RESTART;
    sigemptyset(&sa_int.sa_mask);
    
    if (sigaction(SIGINT, &sa_int, NULL) == -1) {
        perror("sigaction SIGINT");
        exit(EXIT_FAILURE);
    }
    printf("[PARENT] SIGINT handler installed\n");
}

// Function for child that sends SIGTERM
void child_sigterm(pid_t parent_pid) {
    printf("[CHILD 1] PID: %d - Will send SIGTERM after 5 seconds\n", getpid());
    
    // Sleep for 5 seconds
    sleep(5);
    
    printf("[CHILD 1] PID: %d - Sending SIGTERM to parent PID: %d\n", 
           getpid(), parent_pid);
    
    // Send SIGTERM to parent
    if (kill(parent_pid, SIGTERM) == -1) {
        perror("kill SIGTERM");
        exit(EXIT_FAILURE);
    }
    
    // Wait a bit then exit
    sleep(1);
    exit(EXIT_SUCCESS);
}

// Function for child that sends SIGINT
void child_sigint(pid_t parent_pid) {
    printf("[CHILD 2] PID: %d - Will send SIGINT after 10 seconds\n", getpid());
    
    // Sleep for 10 seconds
    sleep(10);
    
    printf("[CHILD 2] PID: %d - Sending SIGINT to parent PID: %d\n", 
           getpid(), parent_pid);
    
    // Send SIGINT to parent
    if (kill(parent_pid, SIGINT) == -1) {
        perror("kill SIGINT");
        exit(EXIT_FAILURE);
    }
    
    // Wait a bit then exit
    sleep(1);
    exit(EXIT_SUCCESS);
}

int main() {
    pid_t pid1, pid2;
    struct timespec start_time, current_time;
    
    // Get start time
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    printf("\n========================================\n");
    printf("        SIGNAL HANDLING DEMO\n");
    printf("========================================\n");
    printf("[PARENT] PID: %d - Starting signal handling demonstration\n", getpid());
    printf("[PARENT] Setting up signal handlers...\n");
    
    // Set up signal handlers
    setup_signal_handlers();
    
    printf("\n[PARENT] Creating child processes...\n");
    
    // Create first child for SIGTERM
    pid1 = fork();
    if (pid1 < 0) {
        perror("fork 1");
        exit(EXIT_FAILURE);
    } else if (pid1 == 0) {
        // Child 1
        child_sigterm(getppid());
    }
    
    // Create second child for SIGINT
    pid2 = fork();
    if (pid2 < 0) {
        perror("fork 2");
        // Clean up first child before exiting
        kill(pid1, SIGTERM);
        waitpid(pid1, NULL, 0);
        exit(EXIT_FAILURE);
    } else if (pid2 == 0) {
        // Child 2
        child_sigint(getppid());
    }
    
    // Parent process
    printf("\n[PARENT] Main process running. Waiting for signals...\n");
    
    int seconds = 0;
    while (!shutdown_initiated) {
        clock_gettime(CLOCK_MONOTONIC, &current_time);
        double elapsed = current_time.tv_sec - start_time.tv_sec + 
                        (current_time.tv_nsec - start_time.tv_nsec) / 1e9;
        
        if ((int)elapsed > seconds) {
            seconds = (int)elapsed;
            printf("[PARENT] Time: %d seconds\n", seconds);
        }
        
        // Small sleep to avoid busy waiting
        usleep(100000); // 100ms
    }
    
    printf("\n[PARENT] Cleaning up child processes...\n");
    
    // Wait for children with timeout
    int status;
    pid_t terminated_pid;
    
    // Wait for child 1
    printf("[PARENT] Waiting for child 1 to complete...\n");
    terminated_pid = waitpid(pid1, &status, 0);
    if (terminated_pid == pid1) {
        if (WIFEXITED(status)) {
            printf("[PARENT] Child 1 exited with status: %d\n", WEXITSTATUS(status));
        } else if (WIFSIGNALED(status)) {
            printf("[PARENT] Child 1 terminated by signal: %d\n", WTERMSIG(status));
        }
    }
    
    // Check if SIGINT was received during shutdown
    if (sigint_received && sigterm_received) {
        printf("[PARENT] SIGINT received but already shutting down (SIGTERM handled first)\n");
    }
    
    // Wait for child 2 with non-blocking check
    printf("[PARENT] Waiting for child 2 to complete...\n");
    int wait_count = 0;
    while ((terminated_pid = waitpid(pid2, &status, WNOHANG)) == 0) {
        if (wait_count++ > 10) { // Timeout after 5 seconds
            printf("[PARENT] Child 2 not responding, sending SIGTERM\n");
            kill(pid2, SIGTERM);
            sleep(1);
        } else {
            sleep(1);
        }
    }
    
    if (terminated_pid == pid2) {
        if (WIFEXITED(status)) {
            printf("[PARENT] Child 2 exited with status: %d\n", WEXITSTATUS(status));
        } else if (WIFSIGNALED(status)) {
            printf("[PARENT] Child 2 terminated by signal: %d\n", WTERMSIG(status));
        }
    }
    
    printf("\n[PARENT] All child processes cleaned up\n");
    printf("[PARENT] Performing final cleanup...\n");
    
    // Restore default signal handlers
    signal(SIGTERM, SIG_DFL);
    signal(SIGINT, SIG_DFL);
    
    clock_gettime(CLOCK_MONOTONIC, &current_time);
    double total_time = current_time.tv_sec - start_time.tv_sec + 
                       (current_time.tv_nsec - start_time.tv_nsec) / 1e9;
    
    printf("[PARENT] Signal handling demonstration completed\n");
    printf("[PARENT] Total runtime: %.2f seconds\n", total_time);
    printf("[PARENT] Exit code: %d\n", sigterm_received ? 0 : (sigint_received ? 1 : 0));
    printf("========================================\n\n");
    
    return sigterm_received ? 0 : (sigint_received ? 1 : 0);
}

2. Makefile
makefile

CC = gcc
CFLAGS = -Wall -Wextra -std=c11 -D_POSIX_C_SOURCE=200809L
TARGET = signal_demo
SOURCES = signal_demo.c

all: $(TARGET)

$(TARGET): $(SOURCES)
	$(CC) $(CFLAGS) -o $(TARGET) $(SOURCES)

debug: $(SOURCES)
	$(CC) $(CFLAGS) -g -o $(TARGET)_debug $(SOURCES)

clean:
	rm -f $(TARGET) $(TARGET)_debug signal_advanced signal_block signal_error signal_concurrent signal_child

run: $(TARGET)
	./$(TARGET)

test: $(TARGET)
	@echo "=== Running signal demo ==="
	./$(TARGET) &
	DEMO_PID=$$!; \
	sleep 15; \
	wait $$DEMO_PID; \
	echo "=== Test completed ==="

.PHONY: all clean run test debug

3. signal_advanced.c (Advanced signal features)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <time.h>

// Signal handler for SIGUSR1
void sigusr1_handler(int sig) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    double current_time = ts.tv_sec + ts.tv_nsec / 1e9;
    
    printf("\n╔════════════════════════════════════════╗\n");
    printf("║        SIGNAL HANDLER ACTIVATED        ║\n");
    printf("╠════════════════════════════════════════╣\n");
    printf("║ Signal: SIGUSR1 (%d)%*s║\n", sig, 27, "");
    printf("║ Time received: %.2f seconds%*s║\n", current_time, 18, "");
    printf("║ Custom user signal 1 received%*s║\n", 12, "");
    printf("╚════════════════════════════════════════╝\n");
}

// Signal handler for SIGUSR2
void sigusr2_handler(int sig) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    double current_time = ts.tv_sec + ts.tv_nsec / 1e9;
    
    printf("\n╔════════════════════════════════════════╗\n");
    printf("║        SIGNAL HANDLER ACTIVATED        ║\n");
    printf("╠════════════════════════════════════════╣\n");
    printf("║ Signal: SIGUSR2 (%d)%*s║\n", sig, 27, "");
    printf("║ Time received: %.2f seconds%*s║\n", current_time, 18, "");
    printf("║ Custom user signal 2 received%*s║\n", 12, "");
    printf("╚════════════════════════════════════════╝\n");
}

void setup_handlers() {
    struct sigaction sa;
    
    printf("[ADVANCED] Setting up multiple signal handlers...\n");
    
    // Setup SIGUSR1
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = sigusr1_handler;
    sigaction(SIGUSR1, &sa, NULL);
    
    // Setup SIGUSR2
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = sigusr2_handler;
    sigaction(SIGUSR2, &sa, NULL);
    
    printf("[ADVANCED] Installed handlers for: SIGTERM, SIGINT, SIGUSR1, SIGUSR2\n");
}

int main() {
    pid_t child_pid;
    
    printf("\n[ADVANCED] Advanced Signal Handling Demo\n");
    
    // Setup handlers (including SIGTERM and SIGINT from previous example)
    setup_handlers();
    
    child_pid = fork();
    if (child_pid == 0) {
        // Child process
        pid_t parent = getppid();
        printf("[CHILD] Will send SIGUSR1 at 3s, SIGUSR2 at 6s, SIGTERM at 9s\n");
        
        sleep(3);
        kill(parent, SIGUSR1);
        
        sleep(3); // Total 6 seconds
        kill(parent, SIGUSR2);
        
        sleep(3); // Total 9 seconds
        kill(parent, SIGTERM);
        
        exit(0);
    } else if (child_pid > 0) {
        // Parent process
        printf("[ADVANCED] Waiting for signals...\n");
        
        while (1) {
            pause(); // Wait for any signal
        }
    }
    
    return 0;
}

4. signal_block.c (Signal blocking demonstration)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>

int main() {
    sigset_t block_set, old_set;
    
    printf("[SIGNAL BLOCK] Blocking SIGINT for 5 seconds...\n");
    
    // Initialize empty signal set
    sigemptyset(&block_set);
    
    // Add SIGINT to the set
    sigaddset(&block_set, SIGINT);
    
    // Block SIGINT
    if (sigprocmask(SIG_BLOCK, &block_set, &old_set) == -1) {
        perror("sigprocmask");
        return 1;
    }
    
    printf("[SIGNAL BLOCK] SIGINT is now blocked\n");
    printf("[SIGNAL BLOCK] Try sending SIGINT (Ctrl+C) - it will be queued\n");
    
    // Wait for 5 seconds while SIGINT is blocked
    for (int i = 5; i > 0; i--) {
        printf("%d... ", i);
        fflush(stdout);
        sleep(1);
    }
    
    printf("\n[SIGNAL BLOCK] Unblocking SIGINT...\n");
    
    // Restore original signal mask
    if (sigprocmask(SIG_SETMASK, &old_set, NULL) == -1) {
        perror("sigprocmask");
        return 1;
    }
    
    printf("[SIGNAL BLOCK] Queued SIGINT signals delivered!\n");
    
    // Install handler for SIGINT
    signal(SIGINT, [](int sig) {
        printf("[INTERRUPT] Signal received after blocking period\n");
        exit(0);
    });
    
    // Wait for signal
    pause();
    
    return 0;
}

5. signal_error.c (Error handling demonstration)
c

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <errno.h>
#include <string.h>

int main() {
    struct sigaction sa;
    
    printf("[SIGNAL ERROR] Testing invalid signal handling...\n");
    
    // Test 1: Try to install handler for invalid signal
    printf("[SIGNAL ERROR] Attempting to install handler for invalid signal 99...\n");
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = SIG_DFL;
    
    if (sigaction(99, &sa, NULL) == -1) {
        printf("Error: sigaction failed: %s\n", strerror(errno));
    }
    
    // Test 2: Try to send signal to non-existent process
    printf("[SIGNAL ERROR] Testing signal to non-existent process...\n");
    if (kill(999999, SIGTERM) == -1) {
        printf("Error: kill failed: %s\n", strerror(errno));
    }
    
    // Test 3: Try to send invalid signal
    printf("[SIGNAL ERROR] Testing invalid signal number...\n");
    if (kill(getpid(), 99) == -1) {
        printf("Error: kill with invalid signal failed: %s\n", strerror(errno));
    }
    
    printf("[SIGNAL ERROR] All error tests completed\n");
    return 0;
}

6. signal_concurrent.c (Concurrent signal handling)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>

volatile int signal_count = 0;

void sigusr1_handler(int sig) {
    signal_count++;
    printf("[CONCURRENT] Signal %d received\n", signal_count);
}

int main() {
    pid_t child_pid;
    struct sigaction sa;
    
    printf("[CONCURRENT] Testing rapid signal delivery...\n");
    
    // Setup handler
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = sigusr1_handler;
    sa.sa_flags = SA_RESTART;
    sigaction(SIGUSR1, &sa, NULL);
    
    child_pid = fork();
    if (child_pid == 0) {
        // Child: Send 5 rapid signals
        pid_t parent = getppid();
        printf("[CONCURRENT] Child will send 5 rapid SIGUSR1 signals\n");
        
        for (int i = 0; i < 5; i++) {
            kill(parent, SIGUSR1);
            usleep(100000); // 100ms between signals
        }
        
        // Send SIGTERM to end program
        sleep(1);
        kill(parent, SIGTERM);
        
        exit(0);
    } else {
        // Parent: Wait for signals
        printf("[CONCURRENT] Waiting for signals...\n");
        
        while (1) {
            pause(); // Wait for signal
        }
    }
    
    return 0;
}

7. run_signal_tests.sh (Test script)
bash

#!/bin/bash

echo "=== Signal Handling Test Suite ==="
echo "Compiling programs..."
make clean
make

echo ""
echo "=== Test 1: Main Signal Demo ==="
./signal_demo &
PID=$!
sleep 15
wait $PID

echo ""
echo "=== Test 2: Manual Signal Testing ==="
./signal_demo &
PID=$!
sleep 2
echo "Sending SIGTERM manually..."
kill -TERM $PID
wait $PID

echo ""
echo "=== Test 3: Advanced Signals ==="
gcc -o signal_advanced signal_advanced.c
./signal_advanced &
PID=$!
sleep 10
wait $PID

echo ""
echo "=== Test 4: Signal Blocking ==="
gcc -o signal_block signal_block.c
echo "Note: Press Ctrl+C during the countdown"
./signal_block

echo ""
echo "=== Test 5: Error Handling ==="
gcc -o signal_error signal_error.c
./signal_error

echo ""
echo "=== Test 6: Concurrent Signals ==="
gcc -o signal_concurrent signal_concurrent.c
./signal_concurrent &
PID=$!
sleep 3
wait $PID

echo ""
echo "=== All tests completed ==="

8. signal_child.c (Signal handling in child processes)
c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

void child_signal_handler(int sig) {
    printf("[CHILD] Received SIGTERM - Child handling signal\n");
    printf("[CHILD] Child exiting gracefully\n");
    exit(0);
}

int main() {
    pid_t child_pid;
    
    printf("[PARENT] Creating child with its own signal handler\n");
    
    child_pid = fork();
    if (child_pid == 0) {
        // Child process
        signal(SIGTERM, child_signal_handler);
        printf("[CHILD] Installed SIGTERM handler\n");
        
        // Child runs indefinitely
        while (1) {
            sleep(1);
        }
    } else {
        // Parent process
        printf("[PARENT] Sending SIGTERM to child after 3 seconds\n");
        sleep(3);
        
        kill(child_pid, SIGTERM);
        
        // Wait for child
        int status;
        waitpid(child_pid, &status, 0);
        
        if (WIFEXITED(status)) {
            printf("[PARENT] Child exited with status: %d\n", WEXITSTATUS(status));
        }
    }
    
    return 0;
}
